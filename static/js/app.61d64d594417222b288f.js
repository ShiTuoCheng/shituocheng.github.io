webpackJsonp([1],{"+7ap":function(n,t){n.exports='<h4 id="-">看到很多人都说 == 检查值相等，=== 检查值和类型是否相等。但是应该是 == 允许在比较中进行强制类型转换，而 === 不进行强制类型转换。</h4>\n<h4 id="-es-11-9-3-">而且==比较算法，根据es规范的11.9.3章节所述为 抽象相等比较算法：</h4>\n<blockquote>\n<p>比较运算x==y, 其中x和 y是值，产生true或者false。这样的比较按如下方式进行：<br></p>\n</blockquote>\n<blockquote>\n<p>若Type(x)与Type(y)相同， 则<br>\n若Type(x)为Undefined， 返回true。<br>\n若Type(x)为Null， 返回true。<br>\n若Type(x)为Number， 则<br>\n若x为NaN， 返回false。<br>\n若y为NaN， 返回false。<br>\n若x与y为相等数值， 返回true。<br>\n若x 为 +0 且 y为−0， 返回true。<br>\n若x 为 −0 且 y为+0， 返回true。<br>\n返回false。<br>\n若Type(x)为String, 则当x和y为完全相同的字符序列（长度相等且相同字符在相同位置）时返回true。 否则， 返回false。<br>\n若Type(x)为Boolean, 当x和y为同为true或者同为false时返回true。 否则， 返回false。<br>\n当x和y为引用同一对象时返回true。否则，返回false。<br>\n若x为null且y为undefined， 返回true。<br>\n若x为undefined且y为null， 返回true。<br>\n若Type(x) 为 Number 且 Type(y)为String， 返回comparison x == ToNumber(y)的结果。<br>\n若Type(x) 为 String 且 Type(y)为Number，<br>\n返回比较ToNumber(x) == y的结果。<br>\n若Type(x)为Boolean， 返回比较ToNumber(x) == y的结果。<br>\n若Type(y)为Boolean， 返回比较x == ToNumber(y)的结果。<br>\n若Type(x)为String或Number，且Type(y)为Object，返回比较x == ToPrimitive(y)的结果。<br>\n若Type(x)为Object且Type(y)为String或Number， 返回比较ToPrimitive(x) == y的结果。<br>\n返回false。<br>\n按以上相等之定义：<br></p>\n</blockquote>\n<blockquote>\n<p>字符串比较可以按这种方式强制执行: &quot;&quot; + a == &quot;&quot; + b 。<br>\n数值比较可以按这种方式强制执行: +a == +b 。<br>\n布尔值比较可以按这种方式强制执行: !a == !b 。<br>\n 等值比较操作保证以下不变：<br></p>\n</blockquote>\n<blockquote>\n<p>A != B 等价于 !(A==B) 。<br>\nA == B 等价于 B == A ，除了A与B的执行顺序。<br>\n相等运算符不总是传递的。例如，两个不同的String对象，都表示相同的字符串值； == 运算符认为每个String对象都与字符串值相等，但是两个字符串对象互不相等。例如：<br></p>\n</blockquote>\n<blockquote>\n<p>new String(&quot;a&quot;) == &quot;a&quot; 和 &quot;a&quot; == new String(&quot;a&quot;) 皆为true。<br>\nnew String(&quot;a&quot;) == new String(&quot;a&quot;) 为false。<br>\n字符串比较使用的方式是简单地检测字符编码单元序列是否相同。不会做更复杂的、基于语义的字符或者字符串相等的定义以及Unicode规范中定义的collating order。所以Unicode标准中认为相等的String值可能被检测为不等。实际上这一算法认为两个字符串已经是经过规范化的形式。</p>\n</blockquote>\n<h2 id="-">个人总结：</h2>\n<h4 id="1-">1.两个对象指向一个值得时候，不发生强制类型转换。</h4>\n<h4 id="2-">2.== 在比较两个不同类型的值的时候，会发生隐式强制类型转换，会将其中之一或两者都转换为相同的类型后再进行比较。</h4>\n<h4 id="3-x-y-42-42-true-42-42-false">3.字符串和数字之间的相等比较 x == y ： ‘42’ == 42// true ‘42’===42// false</h4>\n<h5 id="-1-type-x-type-y-x-tonumber-y-">（1）如果Type(x)为数字，Type(y)为字符串，则会 x == ToNumber(y)</h5>\n<h5 id="-2-type-x-type-y-tonumber-x-y">（2）如果Type(x)为字符串，Type(y)为数字，则会 ToNumber(x) == y</h5>\n<h4 id="4-42-true-false">4.其他类型和布尔值之间的比较 “42” == true // false</h4>\n<h5 id="-1-type-x-tonumber-x-y">（1）如果Type(x)为布尔值，则会 ToNumber(x) == y</h5>\n<h5 id="-2-type-y-tonumber-y-x">（2）如果Type(y)为布尔值，则会 ToNumber(y) == x</h5>\n'},"8tjr":function(n,t){n.exports='<h4 id="-">客户端存储笔记</h4>\n<h5 id="1-localstorage-sessionstorage">1.localStorage和sessionStorage</h5>\n<h6 id="-">两者的区别在于存储的有效期和作用域的不同：数据可以存储多长时间以及谁拥有数据的访问权。</h6>\n<h6 id="localstorge-web-localstorage-document-br-1-br-2-br-3-br-localstorage-br-sessionstorage-localstorage-sessionstorage-br-localstorge-sessionstorage-sessionstorage-sessionstorage-sessionstorage-">localStorge存储的数据是永久性的，除非web应用可以删除存储的数据，否则永远不会过期。localstorage的作用域是限定在文档元document级别的，因此以下每个都拥有不同的文档元:<br>1.不同协议<br>2.不同主机名.<br>3.不同端口。<br>同源的文档间共享同样的localStorage数据。它们可以互相读区对方的数据，甚至可以覆盖对方的数据。但是，非同源的文档间互相都不读取或者覆盖对方的数据。<br>通过sessionStorage存储的数据和通过localStorage存储的数据的有效期也是不同：前者的有效期和存储数据的脚本所在的最顶层的窗口或者是浏览器标签也是一样的。一旦窗口或者标签页被永久关闭了，纳闷通过所有sessionStorage存储的数据也都被删除了。<br>与localStorge一样，sessionStorage的作用域也是限定在文档源中，一次非同源文档间都是无法共享sessionStorage的。不仅如此，sessionStorage的作用域还被限定在窗口中。如果同源的文档渲染在不同浏览器标签页中，那么它们互相之间拥有的是各自的sessionStorage数据。</h6>\n<h5 id="2-cookie">2.cookie</h5>\n<h6 id="cookie-web-web-cookie-">cookie数据会自动在web浏览器和web服务器之间传输的，因此服务端脚本就可以读、写存储在客户端的cookie的值。</h6>\n<h5 id="-">换句话说：</h5>\n<blockquote>\n<p>三者的异同：上面的使用方式说好了，下面就唠唠三者之间的区别，这个问题其实很多大厂面试的时候也都会问到，所以可以注意一下这几个之间的区别。<br></p>\n</blockquote>\n<p>生命周期：cookie：可设置失效时间，没有设置的话，默认是关闭浏览器后失效。\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;localStorage：除非被手动清除，否则将会永久保存。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sessionStorage： 仅在当前网页会话下有效，关闭页面或浏览器后就会被清除。<br>\n存放数据大小：cookie：4KB左右。<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;localStorage和sessionStorage：可以保存5MB的信息。<br>\nhttp请求：<br>cookie：每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题。\nlocalStorage和sessionStorage：仅在客户端（即浏览器）中保存，不参与和服务器的通信。<br>\n易用性：cookie：需要程序员自己封装，源生的Cookie接口不友好。<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;localStorage和sessionStorage：源生接口可以接受，亦可再次封装来对Object和Array有更好的支持。</p>\n'},AnvG:function(n,t){},DvMQ:function(n,t){},HO6x:function(n,t){},IPii:function(n,t){n.exports='<h4 id="-css-js-">总结css以及js加在对页面的影响</h4>\n<h5 id="1-css-dom-dom-dom-css-cssom-cssom-dom-renderer-gui-">1.css不会阻塞dom树的解析，但是会阻塞dom树的渲染。这就是为什么打开网页刚开始都是白屏。其实打开调试工具，dom树已经被解析出来了。但是css可能还没有下载完或者没有解析为cssom树。若cssom解析完成，会和dom树一起被解析成renderer树，通过浏览器的页面进程的gui线程渲染到屏幕上。</h5>\n<p><img src="https://sfault-image.b0.upaiyun.com/137/309/1373095523-5a658fc12f1fd_articlex" alt=""></p>\n<h5 id="2-js-dom-dom-dom-">2.js文件即会阻塞dom加载也会阻塞dom渲染。之所以会阻塞，是因为脚本可能会包含改变当前dom树的语句。</h5>\n<blockquote>\n<p>js只会阻塞后续dom的解析和渲染，而不是整颗dom树。这就是为什么把脚本放在页面底部的原因。脚本在下载时已经正常显示了。但浏览器的加入表示仍然会提示页面正在加载当中。</p>\n</blockquote>\n<h4 id="3-css-head-js-">3.解释css文件放在顶部head中，js放在页面底部的原因。</h4>\n<blockquote>\n<p>css在解析过程中是不会阻塞DOM树的处理的。但是，一旦将css文件放到html尾部的时候，整个情况就变了。在html文件的末尾，DOM树几乎已经处理完成了，但是，这个时候刚刚解析到css的标签，需要下载css文件，以及构建CSSOM树，这些都是需要时间的。如果在头部时，DOM树和CSSOM树可以一起处理；反之，在尾部，需要等待CSSOM的处理，整个DOM渲染的进程会被阻塞(这样做是为了避免渲染树的重新排版)，这样就会导致性能的下降。</p>\n</blockquote>\n'},JKEz:function(n,t){n.exports='<h4 id="js-">js执行过程的梳理笔记</h4>\n<h5 id="1-javascript-">1.首先javascript为词法作用域。词法作用域就是定义在词法阶段的作用域。换句话说词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的。</h5>\n<h5 id="2-js-">2.首先js调用某个函数前会创建执行上下文</h5>\n<h5 id="3-vo-ao-scope-chain-this-">3.执行上下文分别决定了VO/AO,Scope Chain以及this的指向。</h5>\n<blockquote>\n<p>Context = {</p>\n<blockquote>\n<p>VO/AO: {},</p>\n<p>Scope Chain: [],</p>\n<p>this:</p>\n</blockquote>\n<p>}</p>\n</blockquote>\n<h5 id="4-vo-ao-">4.首先创建VO/AO（这就是为什么会发生变量提升的原因！！！）</h5>\n<h6 id="-1-arguments-">(1) 创建arguments对象，初始化参数名以及赋值。</h6>\n<h6 id="-2-function-">(2) 检查当前上下文中的函数声明，也就是function关键字的函数声明。若没有，则会以函数名称新建立一个属性名称，然后将这个属性名称指向在内存堆中的函数。若函数名称也就是属性名称已经存在，那么该属性会被覆盖指向新的函数。</h6>\n<h6 id="-3-var-undefined-undefined-">(3) 检查当前上下文的变量声明，也就是用var关键字的变量声明。若没有，以变量名新建一个属性，然后赋值一个undefined。若存在当前关键字的声明，则会跳过，防止赋值为undefined。</h6>\n<h5 id="5-">5.其次会创建作用域链</h5>\n<h6 id="-scope-boy-">函数内部有个[[scope]]的属性，当函数创建的时候就会保存所有父变量对象到其中。但却不是完整的作用域链(<a href="https://github.com/mqyqingfeng/Blog/issues/6">这里引用一下这个boy的讲解</a>)。</h6>\n<h5 id="6-this-">6.最后会创建this的指向。</h5>\n<p>// to-do</p>\n'},KfOC:function(n,t){n.exports='<h4 id="http-">HTTP浏览器缓存笔记</h4>\n<blockquote>\n<p>(部分内容参考自《http权威指南)</p>\n</blockquote>\n<h5 id="1-get-">1.缓存的处理步骤（GET报文的基本缓存处理步骤）</h5>\n<h6 id="-1-">（1）接收——缓存从网络中读取抵达的请求报文。</h6>\n<h6 id="-2-url-">（2）解析——缓存对报文进行解析，提取出URL和各种首部。</h6>\n<h6 id="-3-">（3）查询——缓存查看是否有本地副本可用，如果没有，就获取一份副本（并将其保存在本地）。</h6>\n<h6 id="-4-">（4）新鲜度检测——缓存查看以缓存副本是否足够新鲜，如果不是，就询问服务器是否有任何更新。</h6>\n<h6 id="-5-">（5）创建响应——缓存会用新的首部和已缓存的主体来构建一条相应报文。</h6>\n<h6 id="-6-">（6）发送——缓存通过网络将相应发挥给客户端。</h6>\n<h6 id="-7-">（7）日志——缓存可选地创建一个日志文件条目来描述这个事物。</h6>\n<h5 id="2-">2.缓存分为强制缓存和协商缓存(对比缓存)</h5>\n<h6 id="-1-200-from-cache-">(1) 强制缓存：从缓存中取 状态吗为 200（from cache） 跟服务器不沟通，直接从缓存中取。</h6>\n<h6 id="-2-304-not-modified-">(2) 协商缓存：从缓存中取 状态码为 304（not modified） 通过服务器来告知缓存是否可用。</h6>\n<h5 id="3-header-">3.强制缓存相关的header字段</h5>\n<h6 id="-http-1-0-expires-http-1-1-cache-control-max-age-">服务器用http/1.0+的expires首部或者http/1.1的cache-control:max-age响应首部来指定过期日期。</h6>\n<h6 id="-1-expires-">（1）Expires: 指定一个绝对过期的日期。如果日期已经过了，就说明文档不再新鲜了。</h6>\n<h6 id="-2-cache-control-max-age-">（2）cache-control:max-age: 定义了文档的最大使用期——最大的合法生存时间(以秒为单位)。</h6>\n<h6 id="-cache-control-cache-control-">总结：这两个首部本质上是一样的。但是由于cache-control首部使用的是相对时间而不是绝对日期。所以我们更加倾向于使用较新的cache-control首部。绝对日期依赖于计算机的正确设置。</h6>\n<h5 id="4-">4.协商缓存(对比缓存)</h5>\n<h6 id="-1-last-modified-if-modified-since-last-modified-br-ims-br-br-2-if-modified-since-get-br-br-if-modified-since-304-not-modified-304-not-modified-response-header-last-modified-header-last-modified-304-response-header-">(1) Last-Modified/If-Modified-Since: 如果从指定日期之后文档被修改过了，就执行请求的方法。可以与Last-Modified服务器响应首部配合使用，只有在内容被修改后与已缓存版本有所不同的时候才获取内容。<br>只有自某个日期之后资源发生了变化的时候，IMS请求才会制定服务器执行请求:<br><br>(2) 如果自指定日期后，文档被修改了, if-modified-since条件就为真，通常get会执行。携带新首部的新文档会被返回给缓存，新首部除了其他信息之外，还包含了一个新的过期日期。<br><br>换句话说,服务器再次收到资源请求时，根据浏览器传过来If-Modified-Since和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。当服务器返回304 Not Modified的响应时，response header中不会再添加Last-Modified的header，因为既然资源没有变化，那么Last-Modified也就不会改变，这是服务器返回304时的response header。</h6>\n<h6 id="-3-if-none-match-etags-if-none-match-">(3) If-None-Match/Etags：服务器可以为文档提供特殊的标签，而不是将其与最近修改日期相匹配，这些标签就像序列号一样。如果缓存标签与服务器文档中的标签有所不同，If-None-Match首部就会执行所请求的方法。</h6>\n'},"M/H0":function(n,t){n.exports='<h3 id="javascript-quiz-"><a href="http://perfectionkills.com/javascript-quiz/">Javascript quiz</a> 题目个人解析</h3>\n<pre><code class="lang-js">(function(){\n  return typeof arguments;\n})();\n</code></pre>\n<h5 id="-typeof-object-arguments-es6-array-from-object-object-">首先typeof只会返回原始类型，对于引用类型都会返回object。arguments是类数组对象。虽然可以用es6的扩展运算符或者Array.from()转成数组对象，但是本质上还是object。所以这个会返回object。</h5>\n<pre><code class="lang-js">var f = function g(){ return 23; };\ntypeof g();\n</code></pre>\n<h5 id="-f-function-g-return-23-g-">首先f就是一个函数表达式，不是个函数声明，所以只能在function g(){ return 23; };里面捕获到g的变量。在外部调用肯定会找不到，所以会出错。</h5>\n<h5 id="-undefined-">但为什么不是 &quot;undefined&quot;？</h5>\n<h5 id="-typeof-g-undefined-g-g-error-">这里如果求 typeof g ，会返回 undefined，但求的是 g()，所以会去先去调用函数 g，这里就会直接抛出异常，所以是 Error。</h5>\n<pre><code class="lang-js">(function(x){\n    delete x;\n    return x;\n})(1);\n</code></pre>\n<h5 id="-delete-delete-var-window-global-delete-x-1-">首先，非严格模式下使用delete，总是不会报错；然后，delete在函数内部无法删除传入的参数。所以在全局没有用var来声明变脸的话，其实是在给window或者global增加了一个属性，属性赋值，所以delete可以删掉。这里是不会删掉参数，所以返回x=1。</h5>\n<pre><code class="lang-js">var y = 1, x = y = typeof x;\nx;\n</code></pre>\n<h5 id="-var-undefined-">首先执行上下文创建的时候只会扫描var声明的变量提升到作用域顶部然后赋值为undefined。具体实现参考之前的文章<a href="https://github.com/ShiTuoCheng/Notes/blob/master/execution.md">点我即可</a>所以题目中的代码经过变量提升后就会变为：</h5>\n<pre><code class="lang-js">var y,x;\ny = 1;\ny = typeof x;\nx = y;\nx;\n</code></pre>\n<h5 id="-x-undefined">所以x为&quot;undefined&quot;</h5>\n<pre><code class="lang-js">(function f(f){\n  return typeof f();\n})(function(){ return 1; });\n</code></pre>\n<h5 id="-function-return-1-iife-typeof-f-1-typeof-1-number-">首先是将函数声明function(){ return 1; }当作iife的参数传入。typeof f()相当于执行传入函数 所以返回1 typeof 1 结果为number。</h5>\n<pre><code class="lang-js">var foo = {\n  bar: function() { return this.baz; },\n  baz: 1\n};\n(function(){\n  return typeof arguments[0]();\n})(foo.bar); \n</code></pre>\n<h5 id="-">翻译一下以上语句</h5>\n<pre><code class="lang-js">typeof arguments[0]();\n</code></pre>\n<h5 id="-">相当于</h5>\n<pre><code class="lang-js">(function() { return this.baz; })();\n</code></pre>\n<h5 id="-this-window-global-baz-">所以这时的this指的是window或者global。所以在全局找不到baz属性</h5>\n<h3 id="this-">this绑定规则：</h3>\n<blockquote>\n<p>1.函数是否是new调用（new绑定）？若是，则this指向新对象</p>\n<p>2.函数是否是bind方法返回的（硬绑定）？若是，则this指向指定对象。</p>\n<p>3.函数是否通过apply/call调用（硬绑定）？若是，则this指向指定对象。</p>\n<p>4.是否作为对象的方法调用（隐式绑定）？若是，则this指向该对象</p>\n<p>5.this指向全局</p>\n</blockquote>\n<pre><code class="lang-js">\n  var foo = {\n    bar: function(){ return this.baz; },\n    baz: 1\n  }\n  typeof (f = foo.bar)();\n</code></pre>\n<h5 id="-">解析同上，这里不说了。</h5>\n<pre><code class="lang-js">var f = (function f(){ return &quot;1&quot;; }, function g(){ return 2; })();\ntypeof f;\n</code></pre>\n<h5 id="js-number-">js符号优先级，所以总是返回最后一项 number；</h5>\n<pre><code class="lang-js">var x = 1;\nif (function f(){}) {\n    x += typeof f;\n}\nx;\n</code></pre>\n<h5 id="function-f-x-1undefined-">function f(){}加了括号就变成了函数表达式。函数表达式的名字只能函数内部可见。所以这里x 为1undefined。</h5>\n<pre><code class="lang-js">var x = [typeof x, typeof y][1];\ntypeof typeof x;\n</code></pre>\n<h5 id="var-x-typeof-y-x-undefined-typeof-typeof-undefined-">var x = typeof y; x = &#39;undefined&#39;; typeof typeof &#39;undefined&#39;;</h5>\n<h5 id="-string-">所以这里输出string。</h5>\n<pre><code class="lang-js">(function(foo){\n    return typeof foo.bar;\n})({ foo: { bar: 1 } });\n</code></pre>\n'},NHnr:function(n,t,e){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var o=e("7+uW"),s=e("/ocq"),i={render:function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("header",{staticClass:"c-header",class:{innerHeader:n.floatHeader}},[e("div",{staticClass:"wrapper"},[e("nav",{staticClass:"c-header-nav"},n._l(n.navList,function(t,o){return e("li",{key:t.title,staticClass:"c-header-nav-item",class:{selected:n.navSel===t.url},attrs:{to:t.url},on:{click:function(e){n.clickNav(t.url,o)}}},[n._v("\n        "+n._s(t.title)+"\n        "),e("div",{staticClass:"c-header-bar"})])}))])])},staticRenderFns:[]};var a=e("VU/8")({name:"c-header",data:function(){return{floatHeader:!1,match:!1,navSel:null,navList:[{title:"STC",url:"/"},{title:"ARTICLES",url:"article"},{title:"MEMORIES",url:"memory"},{title:"ABOUT",url:"aboutMe"},{title:"CONTACT",url:"contactMe"}]}},computed:{navObj:function(n){return{selected:this.navSel===n}}},created:function(){this.floatHeader="/"!==this.$route.path},methods:{clickNav:function(n,t){this.$router.push(n),this.navSel=n,this.floatHeader="/"!==this.$route.path}}},i,!1,function(n){e("AnvG")},"data-v-7be5f6a4",null).exports,r=e("mtWM"),c=e.n(r),l=e("Rf8U"),d=e.n(l);o.a.use(d.a,c.a);var u={name:"App",components:{vHeader:a},watch:{$route:function(n,t){var e=n.path.split("/").length,o=t.path.split("/").length;this.transitionName=e<o?"slide-right":"slide-left"}}},p={render:function(){var n=this.$createElement,t=this._self._c||n;return t("div",{attrs:{id:"app"}},[t("v-header"),this._v(" "),t("transition",{attrs:{name:this.transitionName}},[t("router-view")],1)],1)},staticRenderFns:[]};var h=e("VU/8")(u,p,!1,function(n){e("S3DH")},null,null).exports,f=(e("rplX"),{name:"c-button",props:["articlePath"],methods:{open:function(){this.$router.push({name:"articleDetail",params:{path:this.articlePath}}),console.log(this.articlePath)}}}),b={render:function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("div",{staticClass:"c-article-more-btn",on:{click:function(t){n.open()}}},[e("p",{staticClass:"btn-font"},[n._v("More")]),e("div",{staticClass:"btn-arrow"})])},staticRenderFns:[]};var m={name:"article-bar",components:{vButton:e("VU/8")(f,b,!1,function(n){e("tIcb")},"data-v-8fc64564",null).exports},data:function(){return{progressVal:0,isTrans1:!0,isTrans2:!1,titleList1:[],titleList2:[],count:1}},created:function(){this.startProgress(),this.getArticles()},computed:{},destroyed:function(){clearInterval(this.timer)},methods:{getArticles:function(){var n=this;this.$http.get("../../static/titleData.json").then(function(t){n.titleList1=t.data.article.slice(-3),n.titleList2=t.data.article.slice(-6,-3)})},randomArr:function(n){for(var t=n.length-1;t>0;t--){var e=Math.floor(Math.random()*t),o=[n[e],n[t]];n[t]=o[0],n[e]=o[1]}return n},startProgress:function(){var n=this;this.count++,this.timer=setInterval(function(){n.progressVal<70?(n.progressVal++,n.count%2==0?(n.isTrans1=!1,n.isTrans2=!0):(n.isTrans1=!0,n.isTrans2=!1)):(n.progressVal=0,n.count%2==0?(n.isTrans1=!0,n.isTrans2=!1):(n.isTrans1=!1,n.isTrans2=!0),clearInterval(n.timer),setTimeout(function(){n.startProgress()},1e3))},100)}}},g={render:function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("section",{staticClass:"c-article"},[e("div",{staticClass:"wrapper"},[e("div",{staticClass:"c-article-bar-bg"}),n._v(" "),e("div",{staticClass:"c-article-bar",style:{width:n.progressVal+"%"}}),n._v(" "),e("transition",{attrs:{name:"slide-fade"}},[n.isTrans1?e("ul",{staticClass:"c-article-list"},n._l(n.titleList1,function(t){return e("li",{key:t.index,staticClass:"c-article-list-item"},[e("p",{staticClass:"c-article-title"},[n._v("\n            "+n._s(t.title)+"\n          ")]),n._v(" "),e("v-button",{attrs:{"article-path":t.path}})],1)})):n._e()]),n._v(" "),e("transition",{attrs:{name:"slide-fade"}},[n.isTrans2?e("ul",{staticClass:"c-article-list last"},n._l(n.titleList2,function(t){return e("li",{key:t.index,staticClass:"c-article-list-item"},[e("p",{staticClass:"c-article-title"},[n._v("\n            "+n._s(t.title)+"\n          ")]),n._v(" "),e("v-button",{attrs:{"article-path":t.path}})],1)})):n._e()])],1)])},staticRenderFns:[]};var v={name:"index",components:{vArticleBar:e("VU/8")(m,g,!1,function(n){e("qMph")},"data-v-5fed8683",null).exports},data:function(){return{bgHeight:0,headTitle:"HI - I'M STC AND I SHARE ABOUT CODING TECHINIC ^.^"}},created:function(){this.bgHeight=window.innerHeight-100}},y={render:function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("section",{staticClass:"index"},[e("h1",{staticClass:"index-title"},[n._v(n._s(n.headTitle))]),n._v(" "),n._m(0),n._v(" "),e("div",{staticClass:"index-bg",style:{height:n.bgHeight+"px"}}),n._v(" "),e("div",{staticClass:"clear"})],1)},staticRenderFns:[function(){var n=this.$createElement;return(this._self._c||n)("v-article-bar")}]};var x=e("VU/8")(v,y,!1,function(n){e("DvMQ")},"data-v-3d9f57c8",null).exports,j={render:function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("section",{staticClass:"article wrapper"},[e("ul",{staticClass:"article-list"},[e("transition-group",{attrs:{name:"list"}},n._l(n.titleList,function(t,o){return e("li",{key:o,staticClass:"article-list-item",on:{click:function(e){n.open(t.path)}}},[n._v(n._s(t.title))])}))],1)])},staticRenderFns:[]};var T=e("VU/8")({name:"articlePage",data:function(){return{titleList:[]}},created:function(){var n=this;this.$http.get("../../static/titleData.json").then(function(t){return n.titleList=t.data.article})},methods:{open:function(n){this.$router.push({name:"articleDetail",params:{path:n}})}}},j,!1,function(n){e("UNNM")},"data-v-6ad86130",null).exports,k={name:"ArticleDetail",data:function(){return{PATH:"",article:null,data:[]}},created:function(){this.PATH=this.$router.history.current.params.path,this.data.push(e("+7ap")),this.data.push(e("drp4")),this.data.push(e("JKEz")),this.data.push(e("KfOC")),this.data.push(e("lLlZ")),this.data.push(e("IPii")),this.data.push(e("xSPL")),this.data.push(e("M/H0")),this.data.push(e("Tpo6")),this.data.push(e("PyVc")),this.data.push(e("8tjr")),console.log(document.getElementById("article-detail-content"))},mounted:function(){"../../static/articles/equal.md"===this.PATH?document.getElementById("article-detail-content").innerHTML=this.data[0]:"../../static/articles/eventLoop.md"===this.PATH?document.getElementById("article-detail-content").innerHTML=this.data[1]:"../../static/articles/execution.md"===this.PATH?document.getElementById("article-detail-content").innerHTML=this.data[2]:"../../static/articles/http.md"===this.PATH?document.getElementById("article-detail-content").innerHTML=this.data[3]:"../../static/articles/jsContext.md"===this.PATH?document.getElementById("article-detail-content").innerHTML=this.data[4]:"../../static/articles/opz_css_js.md"===this.PATH?document.getElementById("article-detail-content").innerHTML=this.data[5]:"../../static/articles/param.md"===this.PATH?document.getElementById("article-detail-content").innerHTML=this.data[6]:"../../static/articles/perfectionkills_js_quiz.md"===this.PATH?document.getElementById("article-detail-content").innerHTML=this.data[7]:"../../static/articles/scope.md"===this.PATH?document.getElementById("article-detail-content").innerHTML=this.data[8]:"../../static/articles/quizeAnswer.md"===this.PATH?document.getElementById("article-detail-content").innerHTML=this.data[9]:"../../static/articles/webStorage.md"===this.PATH&&(document.getElementById("article-detail-content").innerHTML=this.data[10])}},q={render:function(){this.$createElement;this._self._c;return this._m(0)},staticRenderFns:[function(){var n=this.$createElement,t=this._self._c||n;return t("section",{staticClass:"article-detail"},[t("article",{staticClass:"markdown-body",attrs:{id:"article-detail-content"}})])}]};var S=e("VU/8")(k,q,!1,function(n){e("HO6x")},"data-v-3d54e506",null).exports,_=e("//Fk"),C=e.n(_),M=(e("+Uzz"),{name:"aboutMe",data:function(){return{aboutList:[{progress:"0",title:"JavaScript"},{progress:"0",title:"TypeScript"},{progress:"0",title:"CSS"},{progress:"0",title:"HTML"}],isLoaded:!1,listLoaded:!1}},methods:{getSkill:function(){var n=this;this.$http.get("/static/skillData.json").then(function(t){return n.aboutList.map(function(n,e){n.progress=t.data.SkillData[e].progress,n.color=t.data.SkillData[e].color})})}},created:function(){var n=this;new C.a(function(t){setTimeout(function(){n.isLoaded=!0,t()},500)}).then(function(){n.listLoaded=!0}).then(function(){setTimeout(function(){n.getSkill()},1e3)})},watch:{aboutList:{handler:function(n,t){t.forEach(function(n,t){})},deep:!0}}}),w={render:function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("section",{staticClass:"about-wrapper"},[e("h1",{staticClass:"about-tit"},[n._v("About Me")]),n._v(" "),e("hr",{class:{titLine:n.isLoaded}}),n._v(" "),e("h2",{staticClass:"about-skill-tit"},[n._v("Professional Skills")]),n._v(" "),e("ul",{staticClass:"about-list",class:{listContent:n.listLoaded}},n._l(n.aboutList,function(t){return e("li",{key:t.index,staticClass:"about-item"},[e("span",[n._v(n._s(t.title))]),n._v(" "),e("div",{staticClass:"about-item-progress",style:{width:"5"*t.progress+"px",background:t.color}}),n._v(" "),e("span",{staticClass:"about-item-percent"},[n._v(n._s(n._f("percent")(t.progress)))])])}))])},staticRenderFns:[]};var H=e("VU/8")(M,w,!1,function(n){e("PCXm")},"data-v-032229ba",null).exports;o.a.use(s.a);var L=new s.a({routes:[{path:"/",component:x},{path:"/article",component:T},{path:"/articleDetail",name:"articleDetail",component:S},{path:"/aboutMe",name:"aboutMe",component:H}]});o.a.config.productionTip=!1,o.a.filter("percent",function(n){if(n)return n+"%"}),new o.a({el:"#app",router:L,components:{App:h},template:"<App/>"})},PCXm:function(n,t){},PyVc:function(n,t){n.exports='<h4 id="-javascript-quiz">原题目来自：<a href="https://github.com/everget/javascript-quiz">javascript-quiz</a></h4>\n<h6 id="-1-">(1)</h6>\n<pre><code class="lang-js">var x = 1;\n{\n  var x = 2;\n}\nx;\n</code></pre>\n<h6 id="-javascript-window-">首先javascript没有块作用域，所以上面代码可以视为全部在window下运行 所以以上代码如下运行顺序如下:</h6>\n<pre><code class="lang-js">var x = undefined;x = 1; x = 2; // 这里直接覆盖之前的值 防止变为undefined// 最后本题结果就是2.\n</code></pre>\n<h6 id="-2-">(2)</h6>\n<pre><code class="lang-js">if (!(&#39;y&#39; in window)){var y = 1;}\nconsole.log(y);\n</code></pre>\n<h6 id="-javascript-function-var-br-var-y-undefined-br-if-y-in-window-br-y-1-br-br-var-if-undefined-">首先我认为这道题考查的是变量提升，javascript首先对整个代码进行预解析，function和var声明会被提前，所以上面代码就变成了一下顺序：</br>var y = undefined; </br>if (!(&#39;y&#39; in window)){</br>&nbsp; y = 1; </br>}<br>可以看到var声明会被提到全局上面，所以永远也不会进入到if之内。因此本题为undefined。</h6>\n<h6 id="-3-">(3)</h6>\n<pre><code class="lang-js">(function() {var x = y = 3;})();\nconsole.log([typeof x, typeof y]);\n</code></pre>\n<h6 id="-undefined-number-iife-var-x-y-3-x-y-x-undefined-y-">这道题会打印出：[&#39;undefined&#39;, &#39;number&#39;];首先本题为一个自执行函数IIFE，有自己的一个函数作用域，外部无法访问内部的变量但是其内部可以访问到全局变量。之后就好说了，var x = y =3;相当于声明了一个局部变量x和一个全局变量y。所以x在全局当然不能被访问到所以为undefined，反而y能被访问到。</h6>\n<h6 id="-4-">(4)</h6>\n<pre><code class="lang-js">var foo = function bar() {return &#39;bar&#39;;}console.log(typeof bar());\n</code></pre>\n<h6 id="-foo-bar-bar-bar-console-log-typeof-foo-">运行以上代码则会报错。原因我认为首先是将foo赋予了一个匿名函数。而右边的匿名函数bar已经变成了匿名函数的一部分无法被访问到，所以当我们尝试运行bar()的时候，当然会抛出bar没有定义的错误。但如果我们改动一下:console.log(typeof foo());则会正确运行右边匿名函数并打印出返回值的类型。</h6>\n<h6 id="-5-">(5)</h6>\n<pre><code class="lang-js">x = 1;(() =&gt; {return x;var x = 2;\n})();console.log(x);\n</code></pre>\n<h6 id="-1-">以上代码会返回1。这道题其实也是考察的变量提升。首先以上代码会被预解析为以下执行顺序：</h6>\n<pre><code class="lang-js">(() =&gt; {var x = undefined;return x;x = 2;})();x = 1;console.log(x)\n</code></pre>\n<p>所以最后在console中打印的是1；</p>\n<h6 id="-6-">(6)</h6>\n<pre><code class="lang-js">var x = 1;if (function f() {}) {x += typeof f;}console.log(x);\n</code></pre>\n<h6 id="-1undefined-if-f-if-true-function-f-if-true-false-">以上代码会返回1undefined。首先在if判断中声明了一个f的函数对象，所以if会认为是true。因为function f(){}是个对象 , if的括号里面放的东西都会转换成true或者false。</h6>\n<h6 id="-7-">（7）</h6>\n<pre><code class="lang-js">(function f() {function f() {return 1;}return f();function f() {return 2;}})();\n</code></pre>\n<h6 id="-2-javascript-">以上代码会返回2。这道题考查的也是变量提升。在javascript预解析的过程中，以上代码会以以下的执行顺序运行：</h6>\n<pre><code class="lang-js">(function f() {function f() {return 1;function f() { return 2;}return f();})();\n</code></pre>\n<h6 id="-8-">(8)</h6>\n<pre><code class="lang-js">var foo = 11;function bar() {return foo;foo = 10;function foo() {};var foo = &#39;12&#39;;}console.log(bar());\n</code></pre>\n'},S3DH:function(n,t){},Tpo6:function(n,t){n.exports='<blockquote>\n<p>function fun(n, o) {<br>\n &nbsp;console.log(o);<br>\n &nbsp;return {<br>\n &nbsp;&nbsp;&nbsp;fun: function(m) {<br>\n &nbsp;&nbsp;&nbsp;&nbsp;return fun(m, n);<br>\n &nbsp;&nbsp;&nbsp;}<br>\n &nbsp;}<br>\n}<br>\nfun(0).fun(1).fun(2);<br>\nlet fn = fun(0).fun(1).fun;<br>\nfn(2);<br>\nfn(3);<br></p>\n</blockquote>\n<h3 id="-">运行结果为</h3>\n<blockquote>\n<p>undefined\n0\n1\nundefined\n0\n1\n1</p>\n</blockquote>\n<h5 id="1-fun-0-n-0-console-log-undefined-">1.fun(0)时，第一个参数为n=0，所以console.log为undefined。同时返回</h5>\n<blockquote>\n<p>fun: function(m) {<br>\n &nbsp;&nbsp;return fun(m, 0);<br>\n }</p>\n</blockquote>\n<h5 id="2-fun-0-fun-1-m-1-fun-1-0-console-log-0-">2.执行fun(0).fun(1)时，则m=1, 函数为fun(1,0),所以console.log(0),同时返回</h5>\n<blockquote>\n<p>fun: function(m) {<br>\n &nbsp;&nbsp;return fun(m, 0);<br>\n }</p>\n</blockquote>\n<h5 id="3-fun-0-fun-1-fun-2-m-2-fun-2-1-console-log-1-">3.执行fun(0).fun(1).fun(2)时，则m=2, 函数为fun(2,1),所以console.log(1),同时返回</h5>\n<blockquote>\n<p>fun: function(m) {<br>\n &nbsp;&nbsp;return fun(m, 0);<br>\n }</p>\n</blockquote>\n'},UNNM:function(n,t){},drp4:function(n,t){n.exports='<h3 id="event-loop">EVENT LOOP</h3>\n<blockquote>\n<p>setTimeout(() =&gt; {</br>&nbsp; console.log(1);</br>&nbsp;\n  setTimeout(() =&gt; console.log(2), 0);</br>&nbsp; }, 500);</br>setTimeout(() =&gt; {</br>&nbsp; setTimeout(() =&gt; console.log(3), 500);</br>\n}, 250);</br>\nconsole.log(4);</p>\n</blockquote>\n<h6 id="-4-1-2-3-br-1-javascript-console-log-4-4-settimeout-macrotask-br-2-javascript-micro-task-settimeout-macrotask-event-loop-br-3-macrotask-1-console-log-2-console-log-3-settimeout-macrotask-br-4-macro-task-micro-task-console-log-2-console-log-3-settimeout-macrotask-br-5-macro-task-2-3-">以上代码最终会依次打印出4, 1, 2, 3。</br>1.首先javascript会先执行整体代码。这是第一次循环。console.log(4)为整体代码所以先打印出来4。并将两个settimeout中的回调放入macrotask中。</br>2.之后javascript会循环任务队列中的微任务(Micro-task)。而settimeout的回掉属于macrotask，会在下一个event loop中执行。所以本次第二轮回调并没有代码执行。</br>3.接下来的第三次循环，会执行任务队列中的宏任务(Macrotask)所以本轮会打印出1.并且分别将带有console.log(2)和console.log(3)的setTimeout放到macrotask中等待下下次的执行。</br>4.第五次循环为macro-task（这里跳过了第四次循环的micro-task）执行第三次放入任务队列中的任务，则会将将带有console.log(2)和console.log(3)的setTimeout的回调放入下下次macrotask中。</br>5.执行macro-task中的任务，分别打印出2，3。</h6>\n'},lLlZ:function(n,t){n.exports=""},qMph:function(n,t){},tIcb:function(n,t){},xSPL:function(n,t){n.exports='<h4 id="-js-">一道考察js按值传递参数总结加笔记</h4>\n<h5 id="-">原题如下：</h5>\n<pre><code class="lang-js">(function() {\n  var foo = &#39;x&#39;;\n\n  (function (foo) {\n    foo = &#39;y&#39;;\n  })(foo);\n\n  return foo;\n})();\n</code></pre>\n<h5 id="-x-">结果应该返回为&#39;x&#39;。</h5>\n<h5 id="-foo-y-segmentfault-javascript-">但是当时非常不解，为什么foo没有被修改为&#39;y&#39;。还在segmentfault发了一篇求助帖<a href="https://segmentfault.com/q/1010000013340600">（点我）</a>。后来才明白，javascript语言中的函数参数都是按值来传递的。</h5>\n<h3 id="-">什么叫按值传递？</h3>\n<h5 id="-">下面举个例子</h5>\n<pre><code class="lang-js">var test = 10;\n\nfunction test2(test){ \n    ++test;\n}\n\nconsole.log(test) // 还是10\n</code></pre>\n<h5 id="-test-test-">我们可以看到在函数内确实改了test的值，但是对外部的test的值并没有修改。</h5>\n<blockquote>\n<p>借用JavaScript高程上的话来讲：按值传递(call by value)是最常用的求值策略：函数的形参是被调用时所传实参的副本。修改形参的值并不会影响实参。</p>\n</blockquote>\n<h5 id="-">但是如果遇到引用类型，则会在修改行参的同时，改变原始值。再举个例子：</h5>\n<pre><code class="lang-js">var obj = {x : 1};\nfunction foo(o) {\n    o.x = 3;\n}\nfoo(obj);\nconsole.log(obj.x); // 3, 被修改了!\n</code></pre>\n<blockquote>\n<p>按引用传递(call by reference)时，函数的形参接收实参的隐式引用，而不再是副本。这意味着函数形参的值如果被修改，实参也会被修改。同时两者指向相同的值。</p>\n</blockquote>\n<h3 id="-javascript-66-ecmascript-">但是根据《JavaScript高级程序设计》第66页上的话说：“ECMAScript中的所有参数传递的都是值，不可能通过引用传递参数。” 又是怎么回事呢？</h3>\n<h4 id="-boy-">以下是结合 我的理解+<a href="https://github.com/mqyqingfeng/Blog/issues/10">(这个boy的博客及评论)</a>:</h4>\n<h5 id="-">第一个例子:</h5>\n<pre><code class="lang-js">var value = 1;\nfunction foo(v) {\n    v = 2;\n    console.log(v); //2\n}\nfoo(value);\nconsole.log(value) // 1\n</code></pre>\n<h5 id="-foo-v-v-value-v-2-foo-v-value-">首先foo(v)中的v确实复制了外部的value。然后将v指向栈内存中的2，所以只修改了foo内部的v的值。而外部的value却没有改变。</h5>\n<h5 id="-">改变前：</h5>\n<table>\n<thead>\n<tr>\n<th>栈内存</th>\n<th style="text-align:right">堆内存</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>value : 1</td>\n<td style="text-align:right"></td>\n</tr>\n<tr>\n<td>v : 1</td>\n</tr>\n</tbody>\n</table>\n<h5 id="-">改变后：</h5>\n<table>\n<thead>\n<tr>\n<th>栈内存</th>\n<th style="text-align:right">堆内存</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>value : 1</td>\n<td style="text-align:right"></td>\n</tr>\n<tr>\n<td>v : 2</td>\n</tr>\n</tbody>\n</table>\n<h5 id="-">第二个例子:</h5>\n<pre><code class="lang-js">var obj = {\n    value: 1\n};\nfunction foo(o) {\n    o.value = 2;\n    console.log(o.value); //2\n}\nfoo(obj);\nconsole.log(obj.value) // 2\n</code></pre>\n<h5 id="-foo-o-obj-o-value-2-o-obj-value-1-value-2-obj-value-2-">首先foo(o)中复制了外部obj的值。然后将o.value改为2，由于o还是引用着外部的obj对象，所以相当于是改变了原来的指向值 { value: 1 }，变成了{ value: 2 }，所以obj的引用指向最后的更新值 { value: 2 }。</h5>\n<h5 id="-">第三个例子：</h5>\n<pre><code class="lang-js">var obj = {\n    value: 1\n};\nfunction foo(o) {\n    o = 2;\n    console.log(o); //2\n}\nfoo(obj);\nconsole.log(obj.value) // 1\n</code></pre>\n<h5 id="-obj-value-1-foo-o-value-1-o-obj-o-2-o-o-2-value-1-obj-">变量obj引用指向值 { value: 1 }，foo 执行时形参对实参做一次复制使得形参o引用也是指向值 { value: 1 }，这里注意o并不是指向obj；接着执行o = 2，相当于更新了o的引用，使o引用指向常量2，但是其实我们并没有改变原来的指向值 { value: 1 }，所以obj的引用指向值是没有变的。</h5>\n'}},["NHnr"]);
//# sourceMappingURL=app.61d64d594417222b288f.js.map